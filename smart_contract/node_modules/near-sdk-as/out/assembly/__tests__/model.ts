import {
  PersistentDeque,
  PersistentSet,
  PersistentVector,
  PersistentMap
} from ".."
@nearBindgen
export class TextMessage {
  sender: string = defaultValue<string>();
  text: string = defaultValue<string>();
  number: u64 = defaultValue<u64>();
  isRead: bool = defaultValue<bool>();
  public __aspectStrictEquals(ref: TextMessage, stack: Array<usize>, cache: Array<usize>, ignore: StaticArray<i64>): bool {
    if (!ignore.includes(4736522337510227968) && Reflect.equals(this.sender, ref.sender, stack, cache) == Reflect.FAILED_MATCH) return false;
;
    if (!ignore.includes(4746556075765923840) && Reflect.equals(this.text, ref.text, stack, cache) == Reflect.FAILED_MATCH) return false;
;
    if (!ignore.includes(4733557126583025664) && Reflect.equals(this.number, ref.number, stack, cache) == Reflect.FAILED_MATCH) return false;
;
    if (!ignore.includes(4725526744189108224) && Reflect.equals(this.isRead, ref.isRead, stack, cache) == Reflect.FAILED_MATCH) return false;
;
    if (isDefined(super.__aspectStrictEquals)) {
      if (!super.__aspectStrictEquals(ref, stack, cache, StaticArray.concat(ignore, [4736522337510227968, 4746556075765923840, 4733557126583025664, 4725526744189108224] as StaticArray<i64>))) return false;
;
    }
    return true;
  }
  public __aspectAddReflectedValueKeyValuePairs(reflectedValue: i32, seen: Map<usize, i32>, ignore: StaticArray<i64>): void {
    if (isDefined(super.__aspectAddReflectedValueKeyValuePairs)) {
      super.__aspectAddReflectedValueKeyValuePairs(reflectedValue, seen, StaticArray.concat(ignore, [4736522337510227968, 4746556075765923840, 4733557126583025664, 4725526744189108224] as StaticArray<i64>));
    }
    if (!ignore.includes(4736522337510227968)) {
      __aspectPushReflectedObjectKey(reflectedValue, Reflect.toReflectedValue("sender", seen));
      __aspectPushReflectedObjectValue(reflectedValue, Reflect.toReflectedValue(this.sender, seen));
    }
    if (!ignore.includes(4746556075765923840)) {
      __aspectPushReflectedObjectKey(reflectedValue, Reflect.toReflectedValue("text", seen));
      __aspectPushReflectedObjectValue(reflectedValue, Reflect.toReflectedValue(this.text, seen));
    }
    if (!ignore.includes(4733557126583025664)) {
      __aspectPushReflectedObjectKey(reflectedValue, Reflect.toReflectedValue("number", seen));
      __aspectPushReflectedObjectValue(reflectedValue, Reflect.toReflectedValue(this.number, seen));
    }
    if (!ignore.includes(4725526744189108224)) {
      __aspectPushReflectedObjectKey(reflectedValue, Reflect.toReflectedValue("isRead", seen));
      __aspectPushReflectedObjectValue(reflectedValue, Reflect.toReflectedValue(this.isRead, seen));
    }
  }

  decode<_V = Uint8Array>(buf: _V): TextMessage {
    let json: JSON.Obj;
    if (buf instanceof Uint8Array) {
      json = JSON.parse(buf);
    } else {
      assert(buf instanceof JSON.Obj, "argument must be Uint8Array or Json Object");
      json = <JSON.Obj> buf;
    }
    return this._decode(json);
  }

  static decode(buf: Uint8Array): TextMessage {
    return decode<TextMessage>(buf);
  }

  private _decode(obj: JSON.Obj): TextMessage {
    this.sender = obj.has("sender") ? decode<string, JSON.Obj>(obj, "sender"): defaultValue<string>();
    this.text = obj.has("text") ? decode<string, JSON.Obj>(obj, "text"): defaultValue<string>();
    this.number = obj.has("number") ? decode<u64, JSON.Obj>(obj, "number"): defaultValue<u64>();
    this.isRead = obj.has("isRead") ? decode<bool, JSON.Obj>(obj, "isRead"): defaultValue<bool>();
    return this;
  }

  _encode(name: string | null = "", _encoder: JSONEncoder | null = null): JSONEncoder {
    let encoder = _encoder == null ? new JSONEncoder() : _encoder;
    encoder.pushObject(name);
    encode<string, JSONEncoder>(this.sender, "sender", encoder);
    encode<string, JSONEncoder>(this.text, "text", encoder);
    encode<u64, JSONEncoder>(this.number, "number", encoder);
    encode<bool, JSONEncoder>(this.isRead, "isRead", encoder);
    encoder.popObject();
    return encoder;
  }
  encode(): Uint8Array {
    return this._encode().serialize();
  }

  serialize(): Uint8Array {
    return this.encode();
  }

  toJSON(): string {
    return this._encode().toString();
  }
}
@nearBindgen
export class Collections {
  public getVector(): PersistentVector<string> {
    return new PersistentVector<string>("v");
  }
  public getMap(): PersistentMap<string, string> {
    return new PersistentMap<string, string>("m");
  }
  public getSet(): PersistentSet<string> {
    return new PersistentSet<string>("s");
  }
  public getDeque(): PersistentDeque<string> {
    return new PersistentDeque<string>("dq");
  }
  public __aspectStrictEquals(ref: Collections, stack: Array<usize>, cache: Array<usize>, ignore: StaticArray<i64>): bool {
    if (isDefined(super.__aspectStrictEquals)) {
      if (!super.__aspectStrictEquals(ref, stack, cache, StaticArray.concat(ignore, [] as StaticArray<i64>))) return false;
;
    }
    return true;
  }
  public __aspectAddReflectedValueKeyValuePairs(reflectedValue: i32, seen: Map<usize, i32>, ignore: StaticArray<i64>): void {
    if (isDefined(super.__aspectAddReflectedValueKeyValuePairs)) {
      super.__aspectAddReflectedValueKeyValuePairs(reflectedValue, seen, StaticArray.concat(ignore, [] as StaticArray<i64>));
    }
  }

  decode<_V = Uint8Array>(buf: _V): Collections {
    let json: JSON.Obj;
    if (buf instanceof Uint8Array) {
      json = JSON.parse(buf);
    } else {
      assert(buf instanceof JSON.Obj, "argument must be Uint8Array or Json Object");
      json = <JSON.Obj> buf;
    }
    return this._decode(json);
  }

  static decode(buf: Uint8Array): Collections {
    return decode<Collections>(buf);
  }

  private _decode(obj: JSON.Obj): Collections {
    
    return this;
  }

  _encode(name: string | null = "", _encoder: JSONEncoder | null = null): JSONEncoder {
    let encoder = _encoder == null ? new JSONEncoder() : _encoder;
    encoder.pushObject(name);
    
    encoder.popObject();
    return encoder;
  }
  encode(): Uint8Array {
    return this._encode().serialize();
  }

  serialize(): Uint8Array {
    return this.encode();
  }

  toJSON(): string {
    return this._encode().toString();
  }
}
@nearBindgen
export class Word {
  constructor(public text: string) {}
  public __aspectStrictEquals(ref: Word, stack: Array<usize>, cache: Array<usize>, ignore: StaticArray<i64>): bool {
    if (!ignore.includes(4746556075765923840) && Reflect.equals(this.text, ref.text, stack, cache) == Reflect.FAILED_MATCH) return false;
;
    if (isDefined(super.__aspectStrictEquals)) {
      if (!super.__aspectStrictEquals(ref, stack, cache, StaticArray.concat(ignore, [4746556075765923840] as StaticArray<i64>))) return false;
;
    }
    return true;
  }
  public __aspectAddReflectedValueKeyValuePairs(reflectedValue: i32, seen: Map<usize, i32>, ignore: StaticArray<i64>): void {
    if (isDefined(super.__aspectAddReflectedValueKeyValuePairs)) {
      super.__aspectAddReflectedValueKeyValuePairs(reflectedValue, seen, StaticArray.concat(ignore, [4746556075765923840] as StaticArray<i64>));
    }
    if (!ignore.includes(4746556075765923840)) {
      __aspectPushReflectedObjectKey(reflectedValue, Reflect.toReflectedValue("text", seen));
      __aspectPushReflectedObjectValue(reflectedValue, Reflect.toReflectedValue(this.text, seen));
    }
  }

  decode<_V = Uint8Array>(buf: _V): Word {
    let json: JSON.Obj;
    if (buf instanceof Uint8Array) {
      json = JSON.parse(buf);
    } else {
      assert(buf instanceof JSON.Obj, "argument must be Uint8Array or Json Object");
      json = <JSON.Obj> buf;
    }
    return this._decode(json);
  }

  static decode(buf: Uint8Array): Word {
    return decode<Word>(buf);
  }

  private _decode(obj: JSON.Obj): Word {
    this.text = obj.has("text") ? decode<string, JSON.Obj>(obj, "text"): defaultValue<string>();
    return this;
  }

  _encode(name: string | null = "", _encoder: JSONEncoder | null = null): JSONEncoder {
    let encoder = _encoder == null ? new JSONEncoder() : _encoder;
    encoder.pushObject(name);
    encode<string, JSONEncoder>(this.text, "text", encoder);
    encoder.popObject();
    return encoder;
  }
  encode(): Uint8Array {
    return this._encode().serialize();
  }

  serialize(): Uint8Array {
    return this.encode();
  }

  toJSON(): string {
    return this._encode().toString();
  }
}
export let vector = new PersistentVector<u32>("")
@nearBindgen
export function foo(): string {
  return "Foo";
}