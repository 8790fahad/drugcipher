import {
  u128
} from ".."
let uintarray = Uint8Array.wrap([10, 199, 99, 88, 100, 255, 100].buffer)
@nearBindgen
export class FooBar {
  baz: string = "123";
  u128Val: u128 = u128.Max;
  public __asonPut<U>(ser: U, entryId: u32, fields: Array<u32> = []): void {
    if (!fields.includes(4730768356905320448 as u32)) ser.putField(entryId, this.baz, offsetof<FooBar>("baz"));
;
    if (!fields.includes(-4479398038124625920 as u32)) ser.putField(entryId, this.u128Val, offsetof<FooBar>("u128Val"));
;
    if (isDefined(super.__asonPut)) super.__asonPut(ser, entryId, [4730768356905320448, -4479398038124625920] as Array<u32>.concat(fields));
;
  }

  decode<_V = Uint8Array>(buf: _V): FooBar {
    let json: JSON.Obj;
    if (buf instanceof Uint8Array) {
      json = JSON.parse(buf);
    } else {
      assert(buf instanceof JSON.Obj, "argument must be Uint8Array or Json Object");
      json = <JSON.Obj> buf;
    }
    return this._decode(json);
  }

  static decode(buf: Uint8Array): FooBar {
    return decode<FooBar>(buf);
  }

  private _decode(obj: JSON.Obj): FooBar {
    this.baz = obj.has("baz") ? decode<string, JSON.Obj>(obj, "baz"): "123";
    this.u128Val = obj.has("u128Val") ? decode<u128, JSON.Obj>(obj, "u128Val"): u128.Max;
    return this;
  }

  _encode(name: string | null = "", _encoder: JSONEncoder | null = null): JSONEncoder {
    let encoder = _encoder == null ? new JSONEncoder() : _encoder;
    encoder.pushObject(name);
    encode<string, JSONEncoder>(this.baz, "baz", encoder);
    encode<u128, JSONEncoder>(this.u128Val, "u128Val", encoder);
    encoder.popObject();
    return encoder;
  }
  encode(): Uint8Array {
    return this._encode().serialize();
  }

  serialize(): Uint8Array {
    return this.encode();
  }

  toJSON(): string {
    return this._encode().toString();
  }
}