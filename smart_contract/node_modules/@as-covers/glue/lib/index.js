"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Covers = exports.CoverPoint = exports.CoverPointType = void 0;
/**
 * Import micromatch module. (File globbing)
 */
var mm = require("micromatch");
/**
 * Import `table` module for report text output
 */
var table_1 = require("table");
/**
 * Import YAML formatter
 */
var yaml_1 = __importDefault(require("yaml"));
/** This configuration is used for ascii table output. */
var tableConfig = {
    border: {
        topBody: "\u2500",
        topJoin: "\u252C",
        topLeft: "\u250C",
        topRight: "\u2510",
        bottomBody: "\u2500",
        bottomJoin: "\u2534",
        bottomLeft: "\u2514",
        bottomRight: "\u2518",
        bodyLeft: "\u2502",
        bodyRight: "\u2502",
        bodyJoin: "\u2502",
        joinBody: "\u2500",
        joinLeft: "\u251C",
        joinRight: "\u2524",
        joinJoin: "\u253C",
    },
};
/**
 *
 * @param point - The coverpoint to get the `line:col` of.
 * @returns string
 */
var linecolText = function (point) { return point.line + ":" + point.col; };
/**
 * Generic enum for basic types.
 * - Function (0)
 * - Block (1)
 * - Expression (2)
 */
var CoverPointType;
(function (CoverPointType) {
    CoverPointType[CoverPointType["Function"] = 0] = "Function";
    CoverPointType[CoverPointType["Block"] = 1] = "Block";
    CoverPointType[CoverPointType["Expression"] = 2] = "Expression";
})(CoverPointType = exports.CoverPointType || (exports.CoverPointType = {}));
/**
 * Data model. Represents file name, line, column, type (enum), and id.
 */
var CoverPoint = /** @class */ (function () {
    function CoverPoint(file, line, col, id, type) {
        this.file = file;
        this.line = line;
        this.col = col;
        this.id = id;
        this.type = type;
        this.covered = false;
    }
    return CoverPoint;
}());
exports.CoverPoint = CoverPoint;
/**
 * Model for reports.
 * Calculates input (CoverPoint[]) and outputs statistics
 */
var CoverPointReport = /** @class */ (function () {
    /** Sets this.fileName to a string. */
    function CoverPointReport(fileName) {
        this.fileName = fileName;
        this.coverPoints = [];
        this.calculated = false;
        this.total = 0;
        this.totalCovered = 0;
        this.expressionTotal = 0;
        this.expressionCovered = 0;
        this.expressionCoveredFinite = true;
        this.blockTotal = 0;
        this.blockCovered = 0;
        this.blockCoveredFinite = true;
        this.functionTotal = 0;
        this.functionCovered = 0;
        this.functionCoveredFinite = true;
    }
    /** Calculates the statistics. */
    CoverPointReport.prototype.calculateStats = function () {
        var e_1, _a;
        if (this.calculated) {
            // If already calculated, don't do it again.
            return;
        }
        try {
            for (var _b = __values(this.coverPoints), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                var covered = point.covered ? 1 : 0;
                this.total++;
                this.totalCovered += covered;
                // Increment total points, and the covered points.
                switch (point.type) {
                    case CoverPointType.Expression: {
                        // If its an expression, increment the total expression count.
                        this.expressionTotal++;
                        // If the expression is covered, increment the exressionCovered variable.
                        this.expressionCovered += covered;
                        break;
                    }
                    case CoverPointType.Block: {
                        // If its a block, increment the total block count.
                        this.blockTotal++;
                        // If the block is covered, increment the blockCovered variable.
                        this.blockCovered += covered;
                        break;
                    }
                    case CoverPointType.Function: {
                        // If its a function, increment the total function count.
                        this.functionTotal++;
                        // If the function is covered, increment the functionCovered variable.
                        this.functionCovered += covered;
                        break;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Set calculated to true. Prevents you from re-calculating. (not needed)
        this.calculated = true;
        // Just a few checks.
        if (this.blockTotal === 0)
            this.blockCoveredFinite = false;
        if (this.expressionTotal === 0)
            this.expressionCoveredFinite = false;
        if (this.functionTotal === 0)
            this.functionCoveredFinite = false;
    };
    Object.defineProperty(CoverPointReport.prototype, "coveredPercent", {
        /**  Gets the covered percentage as a string. */
        get: function () {
            this.calculateStats();
            if (this.total === 0)
                return "N/A";
            return Math.round(10 * (this.totalCovered / this.total) * 100) / 10 + "%";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CoverPointReport.prototype, "coveredBlockPercent", {
        /** Gets the covered block percentage as a string.*/
        get: function () {
            this.calculateStats();
            if (this.blockTotal === 0)
                return "N/A";
            return Math.round(10 * (this.blockCovered / this.blockTotal) * 100) / 10 + "%";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CoverPointReport.prototype, "coveredExpressionPercent", {
        /** Gets the covered expression percentage as a string. */
        get: function () {
            this.calculateStats();
            if (this.expressionTotal === 0)
                return "N/A";
            return Math.round(10 * (this.expressionCovered / this.expressionTotal) * 100) /
                10 + "%";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CoverPointReport.prototype, "coveredFunctionPercent", {
        /** Gets the covered function percentage as a string.*/
        get: function () {
            this.calculateStats();
            if (this.functionTotal === 0)
                return "N/A";
            return Math.round(10 * (this.functionCovered / this.functionTotal) * 100) / 10 + "%";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CoverPointReport.prototype, "coveredPointsNumber", {
        /** Outputs the total number of covered points.*/
        get: function () {
            return this.coverPoints.filter(function (val) { return val.covered; }).length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CoverPointReport.prototype, "uncoveredPointsNumber", {
        /** Outputs the total number of uncovered points.*/
        get: function () {
            return this.coverPoints.filter(function (val) { return !val.covered; }).length;
        },
        enumerable: false,
        configurable: true
    });
    return CoverPointReport;
}());
/**
 * The main class. It houses the initializer, imports, and bindings.
 */
var Covers = /** @class */ (function () {
    function Covers(options) {
        if (options === void 0) { options = {
            files: ["**/*.*"],
        }; }
        this.options = options;
        this.coverPoints = new Map();
    }
    /**
     * Installs the as-covers imports into the loaded's imports object.
     * @param imports - loader
     * @returns - loader
     */
    Covers.prototype.installImports = function (imports) {
        imports.__asCovers = {
            cover: this.cover.bind(this),
            coverDeclare: this.coverDeclare.bind(this),
        };
        return imports;
    };
    /**
     * Sets this.loader to the loader. Lets this access the external loader.
     * @param loader - loader
     */
    Covers.prototype.registerLoader = function (loader) {
        this.loader = loader;
    };
    /**
     * Tells Covers that a specific line/column should be executed (cover(id)).
     * Adds id to main coverPoints
     * @param filePtr - The pointer to the filename
     * @param id - A specific hash representing the file, col, and line.
     * @param line - Specifies which line it should occur on
     * @param col - Specifies which column it should occur on
     * @param coverType - Enum value. Function, Exression, or Block.
     */
    Covers.prototype.coverDeclare = function (filePtr, id, line, col, coverType) {
        // Cover points are immutable. (so it's already been added)
        if (this.coverPoints.has(id))
            return;
        // Get filePath. Needs --exportRuntime flag.
        var filePath = this.loader.exports.__getString(filePtr);
        // Ignore if it shouldn't be covered.
        if (!mm.isMatch(filePath, this.options.files))
            return;
        // Create new CoverPoint and add it to the main points.
        var coverPoint = new CoverPoint(filePath, line, col, id, coverType);
        // Sets CoverPoint inside of this.coverPoints
        this.coverPoints.set(id, coverPoint);
    };
    /**
     * Lets Covers know if a cover point has been executed.
     * @param id - The id of the point.
     */
    Covers.prototype.cover = function (id) {
        // If it should be ignored, return.
        if (!this.coverPoints.has(id))
            return;
        // Grab the CoverPoint
        var coverPoint = this.coverPoints.get(id);
        // Set it to covered
        coverPoint.covered = true;
    };
    /**
     * Clears all coverPoints.
     * Useful if user wants to clear everything.
     * Will result in an error if anything is executed afterwards.
     */
    Covers.prototype.reset = function () {
        // Clear (Very very unsafe!)
        this.coverPoints.clear();
    };
    /**
     * Basic report.
     * Splits everything up into files and calculates statistics.
     * Gets the total statistics and pushes it to the end.
     * @returns Map<string, CoverPointReport>
     */
    Covers.prototype.createReport = function () {
        var e_2, _a;
        // The model map to return.
        var results = new Map();
        // Create total statistics. (Appears at the end.)
        var total = new CoverPointReport("total");
        try {
            for (var _b = __values(this.coverPoints), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), _ = _d[0], coverPoint = _d[1];
                // Grab filename
                var fileName = coverPoint.file;
                if (!results.has(fileName))
                    results.set(fileName, new CoverPointReport(fileName));
                // Ensure it exists
                var report = results.get(fileName);
                // Grab report
                // Push stuff to the report and total
                report.coverPoints.push(coverPoint);
                total.coverPoints.push(coverPoint);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        results.set("total", total);
        // Return it.
        return results;
    };
    /**
     * Returns a table that can be logged.
     * Provides a basic visual overview of statistics.
     * @returns string - Table
     */
    Covers.prototype.stringify = function () {
        // Grab report statistics
        var report = this.createReport();
        // Returns an array formatted with the `table` module. Makes it look really nice!
        return table_1.table(__spreadArray([
            // Main titles for columns
            ["File", "Total", "Block", "Func", "Expr", "Uncovered"]
        ], __read(Array.from(report).map(function (_a, i) {
            var _b = __read(_a, 2), file = _b[0], rep = _b[1];
            var uncoveredPoints = rep.coverPoints.filter(function (val) { return !val.covered; });
            return [
                // File name
                file,
                // Total covered for that file (percent)
                rep.coveredPercent,
                // Block percent
                rep.coveredBlockPercent,
                // Func percentage
                rep.coveredFunctionPercent,
                // Expr Percentage
                rep.coveredExpressionPercent,
                // Some stuff to limit uncovered points length.
                i === report.size - 1
                    ? ""
                    : uncoveredPoints.length > 6
                        ? uncoveredPoints.slice(0, 6).map(linecolText).join(", ") + "..."
                        : uncoveredPoints.map(linecolText).join(", "),
            ];
        }))), 
        // Table config. (top)
        tableConfig);
    };
    /**
     * Outputs report as YAML
     * @returns String
     */
    Covers.prototype.toYAML = function () {
        var e_3, _a, e_4, _b;
        // Create the report
        var report = this.createReport();
        report.delete("total");
        // Result object
        var result = {};
        try {
            // Loop over entries
            for (var _c = __values(report.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = __read(_d.value, 2), path = _e[0], reportEntry = _e[1];
                // @ts-ignore
                // Add path if it isn't there.
                if (!result[path])
                    result[path] = {};
                // @ts-ignore
                // Add basic overview for that file
                result[path]["overview"] = {
                    covered: reportEntry.coveredPointsNumber,
                    uncovered: reportEntry.uncoveredPointsNumber,
                    total: reportEntry.coveredPercent,
                    types: {
                        block: reportEntry.coveredBlockPercent,
                        function: reportEntry.coveredFunctionPercent,
                        expression: reportEntry.expressionCoveredFinite,
                    },
                };
                try {
                    // insert the data
                    for (var _f = (e_4 = void 0, __values(reportEntry.coverPoints)), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var coverPoint = _g.value;
                        // @ts-ignore
                        var data = (result[path][
                        // Gets the file and location.
                        coverPoint.file + ":" + coverPoint.line + ":" + coverPoint.col] = {});
                        // @ts-ignore
                        // Add covered prop
                        data["covered"] = coverPoint.covered;
                        // @ts-ignore
                        // add id prop
                        data["id"] = coverPoint.id;
                        // @ts-ignore
                        // add file prop
                        data["file"] = coverPoint.file;
                        // @ts-ignore
                        // add col prop
                        data["column"] = coverPoint.col;
                        // @ts-ignore
                        // add line prop
                        data["line"] = coverPoint.line;
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return yaml_1.default.stringify(result);
    };
    /**
     * Outputs report as CSV
     * @returns String
     */
    Covers.prototype.toCSV = function () {
        var e_5, _a, e_6, _b;
        var result = "File,Covered,ID,Column,Line\n";
        var report = this.createReport();
        try {
            for (var _c = __values(report.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = __read(_d.value, 2), _ = _e[0], reportEntry = _e[1];
                try {
                    for (var _f = (e_6 = void 0, __values(reportEntry.coverPoints)), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var coverPoint = _g.value;
                        var res = [];
                        // File and location
                        res.push(coverPoint.file);
                        // Add covered prop
                        res.push(coverPoint.covered ? "true" : "false");
                        // add id prop
                        res.push(coverPoint.id.toString());
                        // add col prop
                        res.push(coverPoint.col.toString());
                        // add line prop
                        res.push(coverPoint.line.toString());
                        // Push it all to result (CSV Format)
                        result += res.join(",") + "\n";
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_5) throw e_5.error; }
        }
        // Resolve CSV
        return result;
    };
    /**
     * Output a JSON report.
     * Provides a report that can be easily read or saved. (.json)
     * @returns Object
     */
    Covers.prototype.toJSON = function () {
        var e_7, _a, e_8, _b;
        // Create the report
        var report = this.createReport();
        report.delete("total");
        // Result object
        var result = {};
        try {
            // Loop over entries
            for (var _c = __values(report.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = __read(_d.value, 2), path = _e[0], reportEntry = _e[1];
                // @ts-ignore
                // Add path if it isn't there.
                if (!result[path])
                    result[path] = {};
                // @ts-ignore
                // Add basic overview for that file
                result[path]["overview"] = {
                    covered: reportEntry.coveredPointsNumber,
                    uncovered: reportEntry.uncoveredPointsNumber,
                    total: reportEntry.coveredPercent,
                    types: {
                        block: reportEntry.coveredBlockPercent,
                        function: reportEntry.coveredFunctionPercent,
                        expression: reportEntry.expressionCoveredFinite,
                    },
                };
                try {
                    // insert the data
                    for (var _f = (e_8 = void 0, __values(reportEntry.coverPoints)), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var coverPoint = _g.value;
                        // @ts-ignore
                        var data = (result[path][
                        // Gets the file and location.
                        coverPoint.file + ":" + coverPoint.line + ":" + coverPoint.col] = {});
                        // @ts-ignore
                        // Add covered prop
                        data["covered"] = coverPoint.covered;
                        // @ts-ignore
                        // add id prop
                        data["id"] = coverPoint.id;
                        // @ts-ignore
                        // add file prop
                        data["file"] = coverPoint.file;
                        // @ts-ignore
                        // add col prop
                        data["column"] = coverPoint.col;
                        // @ts-ignore
                        // add line prop
                        data["line"] = coverPoint.line;
                    }
                }
                catch (e_8_1) { e_8 = { error: e_8_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                    }
                    finally { if (e_8) throw e_8.error; }
                }
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return result;
    };
    return Covers;
}());
exports.Covers = Covers;
//# sourceMappingURL=index.js.map